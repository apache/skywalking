# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Match the metric by name, order by metric value(such as: avg, percent)
input TopNCondition {
    name: String!
    topN: Int!
    order: Order!
    # When the scope is ServiceInstance or Endpoint,
    # most likely you need a secondary filter.
    # Such as:
    # 1. Get topN service instance in a given service id
    # 2. Get topN endpoint in a given serivce id.
    # Backend will decide the filter id meaning by Scope.
    #
    # Defintely, it is not required by default.
    filterScope: Scope
    filterId: Int
}

type TopNEntity {
    name: String!
    id: ID!
    value: Int!
}

# The aggregation query is different with the metric query.
# All aggregation queries require backend or/and storage do aggregation in query time.
extend type Query {
    # TopN is an aggregation query.
    getTopN(condition: TopNCondition!): [TopNEntity!]!
}