/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package org.apache.skywalking.oal.v2.generator;

import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtField;
import javassist.CtMethod;
import javassist.bytecode.AnnotationsAttribute;
import javassist.bytecode.FieldInfo;
import javassist.bytecode.MethodInfo;
import javassist.bytecode.annotation.Annotation;
import javassist.bytecode.annotation.MemberValue;
import lombok.extern.slf4j.Slf4j;
import org.apache.skywalking.oal.rt.output.AllDispatcherContext;
import org.apache.skywalking.oal.rt.output.DispatcherContext;
import org.apache.skywalking.oal.rt.parser.AnalysisResult;
import org.apache.skywalking.oal.rt.parser.OALScripts;
import org.apache.skywalking.oal.rt.parser.ScriptParser;
import org.apache.skywalking.oal.v2.model.MetricDefinition;
import org.apache.skywalking.oal.v2.parser.OALScriptParserV2;
import org.apache.skywalking.oap.server.core.oal.rt.OALDefine;
import org.apache.skywalking.oap.server.core.source.DefaultScopeDefine;
import org.apache.skywalking.oap.server.core.source.Service;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

/**
 * Deep comparison test between V1 and V2 OAL engines.
 *
 * Uses isolated ClassPools to generate the same OAL scripts with both engines,
 * then compares the generated bytecode in detail:
 * - Class annotations
 * - Fields and their annotations
 * - Methods (signatures and bytecode)
 *
 * Both engines should produce identical bytecode for the same OAL input.
 */
@Slf4j
public class V1V2ComparisonTest {

    private static final String SOURCE_PACKAGE = "org.apache.skywalking.oap.server.core.source.";
    private static final String METRICS_PACKAGE = "org.apache.skywalking.oap.server.core.source.oal.rt.metrics.";

    @BeforeAll
    public static void initializeScopes() {
        try {
            DefaultScopeDefine.Listener listener = new DefaultScopeDefine.Listener();
            listener.notify(Service.class);
        } catch (RuntimeException e) {
            // Scope may already be registered by other tests
        }
    }

    /**
     * Test that V1 and V2 generate identical metrics classes for simple OAL.
     */
    @Test
    public void testMetricsClassIdentical() throws Exception {
        String oal = "service_cpm = from(Service.*).cpm();";

        // Generate with V1 using isolated ClassPool
        ClassPool v1Pool = new ClassPool(true);
        V1GeneratedClasses v1Classes = generateWithV1(oal, v1Pool);

        // Generate with V2 using isolated ClassPool
        ClassPool v2Pool = new ClassPool(true);
        V2GeneratedClasses v2Classes = generateWithV2(oal, v2Pool);

        // Compare metrics classes
        Assertions.assertEquals(1, v1Classes.metricsClasses.size(), "V1 should generate 1 metrics class");
        Assertions.assertEquals(1, v2Classes.metricsClasses.size(), "V2 should generate 1 metrics class");

        CtClass v1Metrics = v1Classes.metricsClasses.get(0);
        CtClass v2Metrics = v2Classes.metricsClasses.get(0);

        log.info("=== Comparing Metrics Classes ===");
        log.info("V1: {}", v1Metrics.getName());
        log.info("V2: {}", v2Metrics.getName());

        compareClasses(v1Metrics, v2Metrics, "Metrics");
    }

    /**
     * Test that V1 and V2 generate identical dispatcher classes.
     */
    @Test
    public void testDispatcherClassIdentical() throws Exception {
        String oal = "service_cpm = from(Service.*).cpm();";

        ClassPool v1Pool = new ClassPool(true);
        V1GeneratedClasses v1Classes = generateWithV1(oal, v1Pool);

        ClassPool v2Pool = new ClassPool(true);
        V2GeneratedClasses v2Classes = generateWithV2(oal, v2Pool);

        Assertions.assertEquals(1, v1Classes.dispatcherClasses.size(), "V1 should generate 1 dispatcher class");
        Assertions.assertEquals(1, v2Classes.dispatcherClasses.size(), "V2 should generate 1 dispatcher class");

        CtClass v1Dispatcher = v1Classes.dispatcherClasses.get(0);
        CtClass v2Dispatcher = v2Classes.dispatcherClasses.get(0);

        log.info("=== Comparing Dispatcher Classes ===");
        log.info("V1: {}", v1Dispatcher.getName());
        log.info("V2: {}", v2Dispatcher.getName());

        compareClasses(v1Dispatcher, v2Dispatcher, "Dispatcher");
    }

    /**
     * Test complex OAL with longAvg function.
     */
    @Test
    public void testLongAvgMetricsIdentical() throws Exception {
        String oal = "service_resp_time = from(Service.latency).longAvg();";

        ClassPool v1Pool = new ClassPool(true);
        V1GeneratedClasses v1Classes = generateWithV1(oal, v1Pool);

        ClassPool v2Pool = new ClassPool(true);
        V2GeneratedClasses v2Classes = generateWithV2(oal, v2Pool);

        CtClass v1Metrics = v1Classes.metricsClasses.get(0);
        CtClass v2Metrics = v2Classes.metricsClasses.get(0);

        log.info("=== Comparing LongAvg Metrics Classes ===");
        compareClasses(v1Metrics, v2Metrics, "LongAvgMetrics");
    }

    /**
     * Test OAL with filter expression.
     */
    @Test
    public void testFilteredMetricsIdentical() throws Exception {
        String oal = "service_cpm_valid = from(Service.*).filter(status == true).cpm();";

        ClassPool v1Pool = new ClassPool(true);
        V1GeneratedClasses v1Classes = generateWithV1(oal, v1Pool);

        ClassPool v2Pool = new ClassPool(true);
        V2GeneratedClasses v2Classes = generateWithV2(oal, v2Pool);

        CtClass v1Metrics = v1Classes.metricsClasses.get(0);
        CtClass v2Metrics = v2Classes.metricsClasses.get(0);

        log.info("=== Comparing Filtered Metrics Classes ===");
        compareClasses(v1Metrics, v2Metrics, "FilteredMetrics");

        // Also compare dispatcher (filter logic is in doMetrics method)
        CtClass v1Dispatcher = v1Classes.dispatcherClasses.get(0);
        CtClass v2Dispatcher = v2Classes.dispatcherClasses.get(0);

        log.info("=== Comparing Filtered Dispatcher Classes ===");
        compareClasses(v1Dispatcher, v2Dispatcher, "FilteredDispatcher");
    }

    /**
     * Test multiple metrics from same source.
     */
    @Test
    public void testMultipleMetricsIdentical() throws Exception {
        String oal = "service_cpm = from(Service.*).cpm();\n"
            + "service_resp_time = from(Service.latency).longAvg();";

        ClassPool v1Pool = new ClassPool(true);
        V1GeneratedClasses v1Classes = generateWithV1(oal, v1Pool);

        ClassPool v2Pool = new ClassPool(true);
        V2GeneratedClasses v2Classes = generateWithV2(oal, v2Pool);

        Assertions.assertEquals(2, v1Classes.metricsClasses.size());
        Assertions.assertEquals(2, v2Classes.metricsClasses.size());

        // Sort by name for consistent comparison
        v1Classes.metricsClasses.sort((a, b) -> a.getName().compareTo(b.getName()));
        v2Classes.metricsClasses.sort((a, b) -> a.getName().compareTo(b.getName()));

        for (int i = 0; i < v1Classes.metricsClasses.size(); i++) {
            log.info("=== Comparing Multiple Metrics {} ===", i);
            compareClasses(v1Classes.metricsClasses.get(i), v2Classes.metricsClasses.get(i), "MultiMetrics" + i);
        }

        // Should have only 1 dispatcher (both metrics from Service)
        Assertions.assertEquals(1, v1Classes.dispatcherClasses.size());
        Assertions.assertEquals(1, v2Classes.dispatcherClasses.size());

        compareClasses(v1Classes.dispatcherClasses.get(0), v2Classes.dispatcherClasses.get(0), "MultiDispatcher");
    }

    private void compareClasses(CtClass v1Class, CtClass v2Class, String context) throws Exception {
        // 1. Compare class names
        Assertions.assertEquals(v1Class.getName(), v2Class.getName(),
            context + ": Class names should match");
        log.info("{}: Class name matches: {}", context, v1Class.getName());

        // 2. Compare superclass
        Assertions.assertEquals(
            v1Class.getSuperclass() != null ? v1Class.getSuperclass().getName() : null,
            v2Class.getSuperclass() != null ? v2Class.getSuperclass().getName() : null,
            context + ": Superclass should match");
        log.info("{}: Superclass matches: {}", context,
            v1Class.getSuperclass() != null ? v1Class.getSuperclass().getName() : "none");

        // 3. Compare interfaces
        String[] v1Interfaces = Arrays.stream(v1Class.getInterfaces())
            .map(CtClass::getName).sorted().toArray(String[]::new);
        String[] v2Interfaces = Arrays.stream(v2Class.getInterfaces())
            .map(CtClass::getName).sorted().toArray(String[]::new);
        Assertions.assertArrayEquals(v1Interfaces, v2Interfaces,
            context + ": Interfaces should match");
        log.info("{}: Interfaces match: {}", context, Arrays.toString(v1Interfaces));

        // 4. Compare class-level annotations
        compareClassAnnotations(v1Class, v2Class, context);

        // 5. Compare fields
        compareFields(v1Class, v2Class, context);

        // 6. Compare methods
        compareMethods(v1Class, v2Class, context);

        // 7. Compare bytecode
        compareBytecode(v1Class, v2Class, context);
    }

    private void compareClassAnnotations(CtClass v1Class, CtClass v2Class, String context) {
        AnnotationsAttribute v1Annos = (AnnotationsAttribute) v1Class.getClassFile()
            .getAttribute(AnnotationsAttribute.visibleTag);
        AnnotationsAttribute v2Annos = (AnnotationsAttribute) v2Class.getClassFile()
            .getAttribute(AnnotationsAttribute.visibleTag);

        if (v1Annos == null && v2Annos == null) {
            log.info("{}: No class-level annotations", context);
            return;
        }

        Assertions.assertEquals(v1Annos != null, v2Annos != null,
            context + ": Both should have or not have class annotations");

        if (v1Annos != null) {
            Annotation[] v1AnnoArray = v1Annos.getAnnotations();
            Annotation[] v2AnnoArray = v2Annos.getAnnotations();

            Assertions.assertEquals(v1AnnoArray.length, v2AnnoArray.length,
                context + ": Annotation count should match");

            for (int i = 0; i < v1AnnoArray.length; i++) {
                compareAnnotation(v1AnnoArray[i], v2AnnoArray[i], context + " class annotation");
            }
            log.info("{}: Class annotations match (count={})", context, v1AnnoArray.length);
        }
    }

    private void compareAnnotation(Annotation v1Anno, Annotation v2Anno, String context) {
        Assertions.assertEquals(v1Anno.getTypeName(), v2Anno.getTypeName(),
            context + ": Annotation type should match");

        // Compare member values
        if (v1Anno.getMemberNames() == null && v2Anno.getMemberNames() == null) {
            return;
        }

        Assertions.assertEquals(
            v1Anno.getMemberNames() != null ? v1Anno.getMemberNames().size() : 0,
            v2Anno.getMemberNames() != null ? v2Anno.getMemberNames().size() : 0,
            context + ": Annotation member count should match");

        if (v1Anno.getMemberNames() != null) {
            for (String memberName : v1Anno.getMemberNames()) {
                MemberValue v1Value = v1Anno.getMemberValue(memberName);
                MemberValue v2Value = v2Anno.getMemberValue(memberName);
                Assertions.assertNotNull(v2Value,
                    context + ": V2 should have member " + memberName);
                Assertions.assertEquals(v1Value.toString(), v2Value.toString(),
                    context + ": Member " + memberName + " should match");
            }
        }
    }

    private void compareFields(CtClass v1Class, CtClass v2Class, String context) throws Exception {
        CtField[] v1Fields = v1Class.getDeclaredFields();
        CtField[] v2Fields = v2Class.getDeclaredFields();

        // Sort fields by name for consistent comparison
        Map<String, CtField> v1FieldMap = new TreeMap<>();
        Map<String, CtField> v2FieldMap = new TreeMap<>();

        for (CtField f : v1Fields) {
            v1FieldMap.put(f.getName(), f);
        }
        for (CtField f : v2Fields) {
            v2FieldMap.put(f.getName(), f);
        }

        Assertions.assertEquals(v1FieldMap.keySet(), v2FieldMap.keySet(),
            context + ": Field names should match");

        for (String fieldName : v1FieldMap.keySet()) {
            CtField v1Field = v1FieldMap.get(fieldName);
            CtField v2Field = v2FieldMap.get(fieldName);

            // Compare field type
            Assertions.assertEquals(v1Field.getType().getName(), v2Field.getType().getName(),
                context + ": Field " + fieldName + " type should match");

            // Compare field modifiers
            Assertions.assertEquals(v1Field.getModifiers(), v2Field.getModifiers(),
                context + ": Field " + fieldName + " modifiers should match");

            // Compare field annotations
            FieldInfo v1FieldInfo = v1Field.getFieldInfo();
            FieldInfo v2FieldInfo = v2Field.getFieldInfo();

            AnnotationsAttribute v1FieldAnnos = (AnnotationsAttribute) v1FieldInfo
                .getAttribute(AnnotationsAttribute.visibleTag);
            AnnotationsAttribute v2FieldAnnos = (AnnotationsAttribute) v2FieldInfo
                .getAttribute(AnnotationsAttribute.visibleTag);

            if (v1FieldAnnos != null && v2FieldAnnos != null) {
                Annotation[] v1AnnoArray = v1FieldAnnos.getAnnotations();
                Annotation[] v2AnnoArray = v2FieldAnnos.getAnnotations();

                // Sort annotations by type name for consistent comparison
                Arrays.sort(v1AnnoArray, (a, b) -> a.getTypeName().compareTo(b.getTypeName()));
                Arrays.sort(v2AnnoArray, (a, b) -> a.getTypeName().compareTo(b.getTypeName()));

                Assertions.assertEquals(v1AnnoArray.length, v2AnnoArray.length,
                    context + ": Field " + fieldName + " annotation count should match");

                for (int i = 0; i < v1AnnoArray.length; i++) {
                    compareAnnotation(v1AnnoArray[i], v2AnnoArray[i],
                        context + " field " + fieldName);
                }
            }
        }

        log.info("{}: Fields match (count={})", context, v1FieldMap.size());
    }

    private void compareMethods(CtClass v1Class, CtClass v2Class, String context) throws Exception {
        CtMethod[] v1Methods = v1Class.getDeclaredMethods();
        CtMethod[] v2Methods = v2Class.getDeclaredMethods();

        // Map methods by signature for comparison
        Map<String, CtMethod> v1MethodMap = new TreeMap<>();
        Map<String, CtMethod> v2MethodMap = new TreeMap<>();

        for (CtMethod m : v1Methods) {
            String sig = m.getName() + m.getSignature();
            v1MethodMap.put(sig, m);
        }
        for (CtMethod m : v2Methods) {
            String sig = m.getName() + m.getSignature();
            v2MethodMap.put(sig, m);
        }

        Assertions.assertEquals(v1MethodMap.keySet(), v2MethodMap.keySet(),
            context + ": Method signatures should match. V1: " + v1MethodMap.keySet()
                + ", V2: " + v2MethodMap.keySet());

        for (String sig : v1MethodMap.keySet()) {
            CtMethod v1Method = v1MethodMap.get(sig);
            CtMethod v2Method = v2MethodMap.get(sig);

            // Compare method modifiers
            Assertions.assertEquals(v1Method.getModifiers(), v2Method.getModifiers(),
                context + ": Method " + sig + " modifiers should match");

            // Compare method bytecode
            MethodInfo v1MethodInfo = v1Method.getMethodInfo();
            MethodInfo v2MethodInfo = v2Method.getMethodInfo();

            // Compare code attribute (bytecode)
            if (v1MethodInfo.getCodeAttribute() != null && v2MethodInfo.getCodeAttribute() != null) {
                byte[] v1Code = v1MethodInfo.getCodeAttribute().getCode();
                byte[] v2Code = v2MethodInfo.getCodeAttribute().getCode();

                Assertions.assertArrayEquals(v1Code, v2Code,
                    context + ": Method " + sig + " bytecode should match");
            }
        }

        log.info("{}: Methods match (count={})", context, v1MethodMap.size());
    }

    private void compareBytecode(CtClass v1Class, CtClass v2Class, String context) throws Exception {
        ByteArrayOutputStream v1Baos = new ByteArrayOutputStream();
        ByteArrayOutputStream v2Baos = new ByteArrayOutputStream();

        v1Class.toBytecode(new DataOutputStream(v1Baos));
        v2Class.toBytecode(new DataOutputStream(v2Baos));

        byte[] v1Bytecode = v1Baos.toByteArray();
        byte[] v2Bytecode = v2Baos.toByteArray();

        Assertions.assertEquals(v1Bytecode.length, v2Bytecode.length,
            context + ": Bytecode length should match");

        Assertions.assertArrayEquals(v1Bytecode, v2Bytecode,
            context + ": Complete bytecode should be identical");

        log.info("{}: Complete bytecode identical ({} bytes)", context, v1Bytecode.length);
    }

    /**
     * Generate classes with V1 engine using isolated ClassPool.
     */
    private V1GeneratedClasses generateWithV1(String oal, ClassPool classPool) throws Exception {
        V1OALDefine define = new V1OALDefine();

        ScriptParser scriptParser = ScriptParser.createFromScriptText(oal, SOURCE_PACKAGE);
        OALScripts scripts = scriptParser.parse();

        // OALListener already applies DeepAnalysis during parsing
        List<AnalysisResult> results = scripts.getMetricsStmts();

        // Build dispatcher context
        AllDispatcherContext allDispatcherContext = new AllDispatcherContext();
        for (AnalysisResult metricsStmt : results) {
            String sourceName = metricsStmt.getFrom().getSourceName();
            DispatcherContext context = allDispatcherContext.getAllContext().computeIfAbsent(sourceName, name -> {
                DispatcherContext absent = new DispatcherContext();
                absent.setSourcePackage(define.getSourcePackage());
                absent.setSource(name);
                absent.setPackageName(name.toLowerCase());
                absent.setSourceDecorator(metricsStmt.getSourceDecorator());
                return absent;
            });
            metricsStmt.setMetricsClassPackage(define.getDynamicMetricsClassPackage());
            metricsStmt.setSourcePackage(define.getSourcePackage());
            context.getMetrics().add(metricsStmt);
        }

        // Generate classes using V1 generator (CtClass only, no JVM loading)
        V1ClassGenerator generator = new V1ClassGenerator(define, classPool);
        V1GeneratedClasses classes = new V1GeneratedClasses();

        for (AnalysisResult metricsStmt : results) {
            classes.metricsClasses.add(generator.generateMetricsCtClass(metricsStmt));
        }

        for (Map.Entry<String, DispatcherContext> entry : allDispatcherContext.getAllContext().entrySet()) {
            classes.dispatcherClasses.add(generator.generateDispatcherCtClass(entry.getKey(), entry.getValue()));
        }

        return classes;
    }

    /**
     * Generate classes with V2 engine using isolated ClassPool.
     */
    private V2GeneratedClasses generateWithV2(String oal, ClassPool classPool) throws Exception {
        V2OALDefine define = new V2OALDefine();
        MetricDefinitionEnricher enricher = new MetricDefinitionEnricher(SOURCE_PACKAGE, METRICS_PACKAGE);
        OALScriptParserV2 parser = OALScriptParserV2.parse(oal);

        List<CodeGenModel> codeGenModels = new ArrayList<>();
        for (MetricDefinition metric : parser.getMetrics()) {
            CodeGenModel model = enricher.enrich(metric);
            codeGenModels.add(model);
        }

        // Build dispatcher context
        Map<String, OALClassGeneratorV2.DispatcherContextV2> dispatcherContextMap = new java.util.HashMap<>();
        for (CodeGenModel model : codeGenModels) {
            String sourceName = model.getSourceName();
            OALClassGeneratorV2.DispatcherContextV2 context = dispatcherContextMap.computeIfAbsent(sourceName, name -> {
                OALClassGeneratorV2.DispatcherContextV2 ctx = new OALClassGeneratorV2.DispatcherContextV2();
                ctx.setSourcePackage(define.getSourcePackage());
                ctx.setSourceName(name);
                ctx.setPackageName(name.toLowerCase());
                ctx.setSourceDecorator(model.getSourceDecorator());
                return ctx;
            });
            context.getMetrics().add(model);
        }

        // Generate classes using V2 generator (CtClass only, no JVM loading)
        V2ClassGenerator generator = new V2ClassGenerator(define, classPool);
        V2GeneratedClasses classes = new V2GeneratedClasses();

        for (CodeGenModel model : codeGenModels) {
            classes.metricsClasses.add(generator.generateMetricsCtClass(model));
        }

        for (Map.Entry<String, OALClassGeneratorV2.DispatcherContextV2> entry : dispatcherContextMap.entrySet()) {
            classes.dispatcherClasses.add(generator.generateDispatcherCtClass(entry.getKey(), entry.getValue()));
        }

        return classes;
    }

    /**
     * Container for V1 generated classes.
     */
    private static class V1GeneratedClasses {
        List<CtClass> metricsClasses = new ArrayList<>();
        List<CtClass> dispatcherClasses = new ArrayList<>();
    }

    /**
     * Container for V2 generated classes.
     */
    private static class V2GeneratedClasses {
        List<CtClass> metricsClasses = new ArrayList<>();
        List<CtClass> dispatcherClasses = new ArrayList<>();
    }

    /**
     * OALDefine for V1 engine tests.
     */
    private static class V1OALDefine extends OALDefine {
        protected V1OALDefine() {
            super("test-v1.oal", SOURCE_PACKAGE);
        }
    }

    /**
     * OALDefine for V2 engine tests.
     */
    private static class V2OALDefine extends OALDefine {
        protected V2OALDefine() {
            super("test-v2.oal", SOURCE_PACKAGE);
        }
    }
}
